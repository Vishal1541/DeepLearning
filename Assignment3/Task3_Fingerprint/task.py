# -*- coding: utf-8 -*-
"""task.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PGfsYWbd8ZnX92t6pfxgWPeXLOJeGGj0
"""

#from google.colab import drive
#drive.mount('/content/drive')
# cd drive/My Drive/Colab Notebooks/assignment3
# !ls
# cd drive/My Drive/Colab Notebooks/assignment3

import numpy as np
import os
import cv2
import matplotlib.pyplot as plt
from keras.utils import to_categorical
from keras.models import Sequential
from keras.layers import Dense, Conv2D, Flatten, BatchNormalization, MaxPooling2D
from keras import metrics
from keras.models import model_from_json
from keras.callbacks import Callback
from sklearn.metrics import confusion_matrix, f1_score, precision_score, recall_score, accuracy_score



# x = cv2.imread(data_path+'/'+lst[100])
# color = [255, 255,255]
# # color = [0,0,0]
# print(x.shape)
# x = cv2.copyMakeBorder(x,0,20,0,80,cv2.BORDER_CONSTANT,value=color)
# print(x.shape)
# plt.imshow(x)

def createData(dir,path):
  data = []
  for i in range(len(dir)):
    x = cv2.imread(path+'/'+dir[i])
    data.append(x)
    print("Input Image :",i)
  
  return np.array(data)

def findMaxLengthWidth(arr):
  mxl = -1
  mxw = -1
  
  for i in arr:
    if mxl < i.shape[0]:
      mxl = i.shape[0]
    if mxw < i.shape[1]:
      mxw = i.shape[1]
  
  return mxl,mxw

# print(data.shape)
# l,w = findMaxLengthWidth(data)
# print(l,w)

def getTrainTestData(data_path):
  lst = os.listdir(data_path)
  lst.sort()

  # for i in range(len(lst)):
  #     print(lst[i])

  # print(len(lst))

  data = createData(lst,data_path)
  mxl,mxw = findMaxLengthWidth(data)

  training_data = []
  testing_data = []
  pos = 0

  for i in data:
    x = cv2.copyMakeBorder(i,0,mxl-i.shape[0],0,mxw-i.shape[1],cv2.BORDER_CONSTANT,value=[255,255,255])

    if pos < 3*len(data)/4:
        training_data.append(x)
    else:
        testing_data.append(x)

    pos +=1

  return np.array(training_data),np.array(testing_data)
  # np.save('train.npy',training_data)
  # np.save('test.npy',testing_data)

data_path = 'Q3/Core_Point/Data'
train_data,test_data = getTrainTestData(data_path)



def getGroundTruthData(gt_path):
  lstt = os.listdir(gt_path)
  lstt.sort()

  # for i in range(len(lst)):
  #     print(lst[i])

  ground_truth = []
  ground_truth_test = []
  pos = 0

  for i in range(len(lstt)):
      x,y = open(gt_path+'/'+lstt[i],"r").readline().split()
      line = []
      line.append(int(x))
      line.append(int(y))
  #     print(i)
      if pos < 3*len(lstt)/4:
          ground_truth.append(line)
      else:
        ground_truth_test.append(line)

      pos +=1

  return np.array(ground_truth),np.array(ground_truth_test)

gt_path = 'Q3/Core_Point/Ground_truth'
gt,gt_test = getGroundTruthData(gt_path)
print(gt.shape)
print(gt_test.shape)

model = Sequential()
model.add(Conv2D(32, kernel_size=20, strides=10, activation="relu", input_shape=(train_data[0].shape[0],train_data[0].shape[1],3)))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=2, strides=2))
model.add(Flatten())
# model.add(Dense(1000, activation='linear'))
model.add(Dense(2, activation='relu'))
model.compile(loss='mse', optimizer='adam', metrics=["accuracy"])
history = model.fit(train_data, gt, validation_data=(test_data,gt_test) ,epochs=10)

# Plot training & validation accuracy values
plt.plot(history.history['acc'])
plt.plot(history.history['val_acc'])
plt.title('Model accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend(['Train', 'Test'], loc='lower right')
# plt.savefig(op_folder + "/accuracy.png", bbox_inches='tight')
plt.show()

# Plot training & validation loss values
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['Train', 'Test'], loc='upper right')
# plt.savefig(op_folder + "/loss.png", bbox_inches='tight')
plt.show()

model.summary()

img_no = 500
ip = []
ip.append(test_data[img_no])
ip = np.array(ip)

op = model.predict(ip)
# print(ip.shape)
x,y = gt_test[img_no][0],gt_test[img_no][1]
print(x)
print(y)
print(op)

